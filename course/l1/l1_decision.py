# -*- coding: utf-8 -*-
"""l1_decision.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1WCBlx0GVuc7T1XK7gJWAvgpi0UeRu9fJ

# Лабораторная работа №1 | Решение заданий

1. Загрузить данные из файла в виде массива numpy типа int32, используя np.loadtxt. Вывести на экран первые 5 строк массива.
"""

import numpy as np

# Путь к загруженному файлу
file_path = 'minutes_n_ingredients2.csv'

# Загрузка данных из файла в виде массива numpy типа int32
data = np.loadtxt(file_path, delimiter=',', dtype=np.int32, skiprows=1)

# Вывод первых 5 строк массива
print(data[:5])

"""2. Вычислите среднее значение, минимум, максимум и медиану по каждому из столбцов, кроме первого."""

data_columns = data[:, 1:]

# Вычисление статистических значений для каждого столбца
mean_values = np.mean(data_columns, axis=0)
min_values = np.min(data_columns, axis=0)
max_values = np.max(data_columns, axis=0)
median_values = np.median(data_columns, axis=0)

# Вывод результатов
print("Средние значения по столбцам:", mean_values)
print("Минимальные значения по столбцам:", min_values)
print("Максимальные значения по столбцам:", max_values)
print("Медианы по столбцам:", median_values)

"""3. Ограничьте сверху значения продолжительности выполнения рецепта значением квантиля q0.75 ."""

# Извлечение столбца `minutes`
minutes = data[:, 1]

# Вычисление квантиля 0.75 для `minutes`
q75 = np.percentile(minutes, 75)

# Ограничение значений в `minutes` значением квантиля
minutes_clipped = np.clip(minutes, None, q75)

# Обновление данных в массиве
data[:, 1] = minutes_clipped

# Вывод первых 5 строк для проверки
print(data[:5])

"""4. Посчитайте, для скольких рецептов указана продолжительность, равная нулю. Замените для таких строк значение в данном столбце на 1."""

# Подсчет количества рецептов с нулевой продолжительностью
num_zero_minutes = np.sum(data[:, 1] == 0)
print("Количество рецептов с нулевой продолжительностью:", num_zero_minutes)

# Замена нулевых значений на 1
data[data[:, 1] == 0, 1] = 1

# Проверка результата
num_zero_minutes_after = np.sum(data[:, 1] == 0)
print("Количество рецептов с нулевой продолжительностью после замены:", num_zero_minutes_after)

"""5. Посчитайте, сколько уникальных рецептов находится в датасете."""

# Извлечение столбца с названиями рецептов (предполагается, что это первый столбец)
recipes = data[:, 0]

# Подсчет количества уникальных рецептов
num_unique_recipes = np.unique(recipes).size

print("Количество уникальных рецептов:", num_unique_recipes)

"""6. Сколько и каких различных значений кол-ва ингредиентов присутвует в рецептах из датасета?"""

# Извлечение столбца с количеством ингредиентов (предполагается, что это второй столбец)
num_ingredients = data[:, 2]

# Нахождение уникальных значений и их количества
unique_ingredients, counts = np.unique(num_ingredients, return_counts=True)

# Вывод результатов
print("Количество различных значений количества ингредиентов:", unique_ingredients.size)
print("Уникальные значения и их количество:")
for value, count in zip(unique_ingredients, counts):
    print(f"Значение: {value}, Количество: {count}")

"""7. Создайте версию массива, содержащую информацию только о рецептах, состоящих не более чем из 5 ингредиентов."""

# Создание маски для рецептов с не более чем 5 ингредиентами
mask = data[:, 2] <= 5

# Создание новой версии массива с использованием маски
filtered_data = data[mask]

# Вывод первых 5 строк отфильтрованного массива
print(filtered_data[:5])

"""8. Для каждого рецепта посчитайте, сколько в среднем ингредиентов приходится на одну минуту рецепта. Найдите максимальное значение этой величины для всего датасета"""

# Вычисление среднего количества ингредиентов на минуту для каждого рецепта
ingredients_per_minute = data[:, 2] / data[:, 1]

# Нахождение максимального значения
max_ingredients_per_minute = np.max(ingredients_per_minute)

print("Максимальное среднее количество ингредиентов на минуту:", max_ingredients_per_minute)

"""9. Вычислите среднее количество ингредиентов для топ-100 рецептов с наибольшей продолжительностью"""

# Сортировка рецептов по продолжительности в порядке убывания
sorted_indices = np.argsort(data[:, 1])[::-1]
sorted_data = data[sorted_indices]

# Выбор топ-100 рецептов
top_100_recipes = sorted_data[:100]

# Вычисление среднего количества ингредиентов для топ-100 рецептов
average_ingredients_top100 = np.mean(top_100_recipes[:, 2])

print("Среднее количество ингредиентов для топ-100 рецептов с наибольшей продолжительностью:", average_ingredients_top100)

"""10. Выберите случайным образом и выведите информацию о 10 различных рецептах"""

import random

# Генерация 10 случайных индексов
random_indices = random.sample(range(data.shape[0]), 10)

# Выбор случайных рецептов
random_recipes = data[random_indices]

# Вывод информации о случайных рецептах
for recipe in random_recipes:
    print("Название:", recipe[0])
    print("Продолжительность (минуты):", recipe[1])
    print("Количество ингредиентов:", recipe[2])
    print("-" * 20)

"""11. Выведите процент рецептов, кол-во ингредиентов в которых меньше среднего."""

# Вычисление среднего количества ингредиентов
average_ingredients = np.mean(data[:, 2])

# Подсчет количества рецептов с количеством ингредиентов меньше среднего
num_recipes_below_average = np.sum(data[:, 2] < average_ingredients)

# Вычисление процента таких рецептов
percentage_below_average = (num_recipes_below_average / data.shape[0]) * 100

print("Процент рецептов с количеством ингредиентов меньше среднего:", percentage_below_average, "%")

"""12. Назовем "простым" такой рецепт, длительность выполнения которого не больше 20 минут и кол-во ингредиентов в котором не больше 5. Создайте версию датасета с дополнительным столбцом, значениями которого являются 1, если рецепт простой, и 0 в противном случае."""

# Создание маски для "простых" рецептов
simple_mask = (data[:, 1] <= 20) & (data[:, 2] <= 5)

# Создание столбца с метками "простой" (1) или "не простой" (0)
simple_column = simple_mask.astype(int)

# Добавление столбца к датасету
data_with_simple = np.column_stack((data, simple_column))

# Вывод первых 5 строк нового датасета
print(data_with_simple[:5])

"""13. Выведите процент "простых" рецептов в датасете"""

# Подсчет количества "простых" рецептов
num_simple_recipes = np.sum(data_with_simple[:, -1])

# Вычисление процента "простых" рецептов
percentage_simple = (num_simple_recipes / data_with_simple.shape[0]) * 100

print("Процент 'простых' рецептов:", percentage_simple)

"""14. Разделим рецепты на группы по следующему правилу. Назовем рецепты короткими, если их продолжительность составляет менее 10 минут; стандартными, если их продолжительность составляет более 10, но менее 20 минут; и длинными, если их продолжительность составляет не менее 20 минут. Создайте трехмерный массив, где нулевая ось отвечает за номер группы (короткий, стандартный или длинный рецепт), первая ось - за сам рецепт и вторая ось - за характеристики рецепта. Выберите максимальное количество рецептов из каждой группы таким образом, чтобы было возможно сформировать трехмерный массив. Выведите форму полученного массива."""

# Создание масок для каждой группы
short_mask = data[:, 1] < 10
standard_mask = (data[:, 1] >= 10) & (data[:, 1] < 20)
long_mask = data[:, 1] >= 20

# Определение максимального количества рецептов в группе
max_recipes_per_group = min(np.sum(short_mask), np.sum(standard_mask), np.sum(long_mask))

# Выбор рецептов из каждой группы
short_recipes = data[short_mask][:max_recipes_per_group]
standard_recipes = data[standard_mask][:max_recipes_per_group]
long_recipes = data[long_mask][:max_recipes_per_group]

# Создание трехмерного массива
grouped_recipes = np.stack((short_recipes, standard_recipes, long_recipes))

# Вывод формы полученного массива
print("Форма трехмерного массива:", grouped_recipes.shape)
